# Valint Gatekeeper Provider
To integrate [OPA Gatekeeper's new ExternalData feature](https://open-policy-agent.github.io/gatekeeper/website/docs/externaldata) with Valint to verify policies on your supply chain.

> This repo is meant for testing Gatekeeper external data feature. Do not use for production.

## Installation

### Installing Gatekeeper
- Deploy Gatekeeper with external data enabled (`--enable-external-data`)
```sh
helm repo add gatekeeper https://open-policy-agent.github.io/gatekeeper/charts
helm install gatekeeper/gatekeeper  \
    --name-template=gatekeeper \
    --namespace gatekeeper-system --create-namespace \
    --set enableExternalData=true \
    --set controllerManager.dnsPolicy=ClusterFirst,audit.dnsPolicy=ClusterFirst \
    --set validatingWebhookTimeoutSeconds=30
```

### Generate TLS certificate and key for the provider
Gatekeeper enforces TLS when communicating with the provider, so certificates must be provided.

1) To generate new certificates, use the script:
- `scripts/generate-tls-cert.sh`

2) This will create CA and certificate files in `certs` directory.

### Installing Provider with Scribe Evidence store
Scribe evidence store allows you store evidence using scribe Service.

### Before you begin
Integrating Scribe Hub with admission controller requires the following credentials that are found in the **Integrations** page. (In your **[Scribe Hub](https://prod.hub.scribesecurity.com/ "Scribe Hub Link")** go to **integrations**)

* **Client ID**
* **Client Secret**

<img src='../../../img/ci/integrations-secrets.jpg' alt='Scribe Integration Secrets' width='70%' min-width='400px'/>

Enable Scribe client and add related `Client ID` and `Client Secret`.

- ```sh
   helm install charts/gatekeeper-valint --name-template=gatekeeper-valint \
   --namespace gatekeeper-valint --create-namespace \
   --set certs.caBundle=$(cat certs/ca.crt | base64 | tr -d '\n') \
   --set certs.tlsCrt="$(cat certs/tls.crt)" \
   --set certs.tlsKey="$(cat certs/tls.key)" \
   --set scribe.enable=true \
   --set scribe.client_id=$SCRIBE_CLIENT_ID \
   --set scribe.client_secret=$SCRIBE_CLIENT_SECRET
  ```
> Credentials will be stored as a secret named `valint-scribe-cred-secret`.
> Tls cert and key are stored as a secret named `gatekeeper-valint-certs`

## Verifing signed evidence
Once you've completed one of the integration steps below, you can configure your rules to verify signed evidence using either X509 certificates or Sigstore Keyless signatures. For example:

```yaml
- uses: <some_rule>
  with:
   signed: true
```

### X509-based Signatures
To enable the provider to verify X509-based signatures, follow these steps:
* Set the `x509.ca` field to specify the CA chain to verify against.
* Set the `valint.attest.default` to default to `x509-env`.

For example, to perform an upgrade with X509-based verification:
```bash
   helm upgrade gatekeeper-valint ./charts/gatekeeper-valint \
   --namespace gatekeeper-valint \
   --reuse-values --force \
   --set valint.attest.default=x509-env \
   --set x509.ca="$(cat certs/evidence.crt)"
```

> Certificate is mapped to `valint-x509-secret` secret.

> Please replace the keys and certificates generated by our `scripts/generate-tls-cert.sh` for evidence signing and verfication with your organization's trusted CA.

### Sigstore Keyless Signatures
To enable the provider to verify Sigstore Keyless signatures, set the `valint.attest.default` field to default to `sigstore`.

For example, to perform an upgrade with sigstore-based verification:
```bash
   helm upgrade gatekeeper-valint ./charts/gatekeeper-valint \
   --namespace gatekeeper-valint \
   --reuse-values --force \
   --set valint.attest.default=sigstore
```


# Demo: Enforcing Image Signing Policies with Gatekeeper Valint
To showcase the enforcement of image signing policies using Gatekeeper Valint, we'll apply a simplistic unsigned image error policy and upgrade our gate accordingly.

Upgrade your gate with the following command,
```bash
helm upgrade gatekeeper-valint ./charts/gatekeeper-valint \
  --values signed_image_policy.yaml \
  --namespace gatekeeper-valint \
  --reuse-values --force
```

<details>
  <summary> `signed_image_policy.yaml` file </summary>

```yaml
select:
  gate: signed_images_gate
  apply:
  - namespace: "" # Any
    glob:
    - "mycompany/**"
    filter-by:
    - target
    policy:
      name: require_signed_images
      rules:
      - name: error_on_unsigned_image
        uses: sboms/artifact-signed@v1
        level: error
        evidence:
          signed: true

valint:
  attest:
    default: sigstore
```

In the provided `signed_image_policy.yaml`, we specify a policy to enforce signature verification for images admitted from the my_company Dockerhub account.
</details>

Now lets try and apply deployments before signing the image.
```bash
kubectl apply -f signed-deployment.yaml 2>&1 | echo -e "$(cat -)"
```

<details>
  <summary> `signed-deployment.yaml` file </summary>

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: signed-deployment
  labels:
    app: signed-deployment
spec:
  replicas: 0 # testing purposes only
  selector:
    matchLabels:
      app: signed-deployment
  template:
    metadata:
      labels:
        app: signed-deployment
    spec:
      containers:
      - name: valid
        image: mycompany/signed:latest
```

</details>

In the output, you should see a rejected admission error due to the unsigned image.

```log
  Error from server (Forbidden): error when creating "signed-deployment.yaml": admission webhook "validation.gatekeeper.sh" denied the request: [gatekeeper-valint] image not accepted: {"errors": [], "responses": [], "status_code": 200, "system_error": "

  Scribe Admission refused 'mycompany/signed:latest' deploy to 'default'.

  - policy check failed, Policies [require_signed_images] failed with the following errors.
  * rule [error_on_signed_image] failed resource not found, no evidence found
  "}
```

To resolve this, sign your image using the Valint tool:

```bash
valint bom mycompany/signed:latest -o attest [FLAGS]
```

Then, reapply the deployment:

```bash
kubectl apply -f signed-deployment.yaml
```

Upon successful deployment, you'll see a detailed evaluation summary in the admission logs, providing insights into the policy checks performed and their outcomes.

```log
[2024-03-11 10:05:27]  INFO Target 'mycompany/signed:latest' results
[2024-03-11 10:05:27]  INFO Policy "require_signed_images" Evaluation Summary: 
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Policy "require_signed_images" Evaluation Summary                                                                         │
├─────────────────────────┬────────┬────────────────────────┬───────────────────┬────────────────────────────────────────────┤
│ RULE NAME               │ SIGNED │ SIGNATURE VERIFICATION │ POLICY EVALUATION │ COMMENT                                    │
├─────────────────────────┼────────┼────────────────────────┼───────────────────┼────────────────────────────────────────────┤
│ error_on_unsigned_image │ true   │ passed                 │                   │ 1/1 evidence origin and signature verified │
├─────────────────────────┼────────┼────────────────────────┼───────────────────┼────────────────────────────────────────────┤
│ AGGREGATE POLICY RESULT │        │                        │ PASSED            │                                            │
└─────────────────────────┴────────┴────────────────────────┴───────────────────┴────────────────────────────────────────────┘
```


# Policy Gate
The Gate Policies in Valint Gatekeeper Provider allow for fine-grained control over policy evaluation for images admitted into the system. 

### Gate Configuration options
```yaml
select:
  gate: default_gate # Requried
  apply:
  - namespace: <string> # Optional
    glob: <string> # Optional
    filter-by: <string> # Optional
    product-key: <string> # Optional
    policy: <object> # Reuquired
```
* `gate`: Specifies the gate name.
* `namespace`: Specifies the namespace to which the policy applies.
* `glob`: Defines the image reference pattern to which the policy is applied, for more details see glob section..
* `filter-by`: Determines the scope of the policy evaluation. Supported options include:
* `target`: Evaluate policies scoped by the imageID for admission.
* `pipeline`: Evaluate policies scoped by the image build runID and workflow.
* `product-key`: Evaluate policies scoped by a specific product.
* `policy`: Set policy to evalute, for more details see [policy details](https://scribe-security.netlify.app/docs/guides/enforcing-sdlc-policy).

> policy gate configuration are mapped to a configmap named `gatekeeper-valint-policies`.

## Filter-By Options 
The filter-by field allows you to specify the scope of the policy evaluation. Below are the available options:

For example, to perform an upgrade to your policy gate:
```bash
   helm upgrade gatekeeper-valint ./charts/gatekeeper-valint \
   --values my_gate.yaml \
   --namespace gatekeeper-valint \
   --reuse-values --force
```

with `my_gate.yaml` file set for example
```yaml
select:
  gate: my_gate
  apply:
  - namespace: "some_namespace"
    glob: 
    - "**"
    filter-by:
    - target
    policy: <object>
```

### Target Evaluation
> Option available for both `scribe` and `OCI` stores.

The target option evaluates policies based on the imageID for admission. This allows you to run policies directly on the images themselves.
```yaml
select:
  gate: image_gate
  apply:
  - namespace: ""
    glob: 
    - "**"
    filter-by:
    - target
    policy:
      name: cluster-policy
      rules:
      - name: fresh-image
        uses: images/fresh-image@v1
        level: warning
        with:
          max_days: 356
```
This policy aims to ensure that images admitted into the system are fresh, defined as being built within the last year. 
The fresh-image rule is applied with a warning level severity.

### Pipeline Evaluation
> Option only available when using `scribe` store.

The pipeline option evaluates policies based on the image build runID and workflow. This allows you to run policies related to the image build pipeline.
```yaml
select:
  gate: pipeline_gate
  apply:
  - namespace: ""
    glob: 
    - "my_company/**"
    filter-by:
    - pipeline
    policy:
      name: pipeline-scanners
      rules:
      - name: check-vulnerabilities
        uses: sarif/verify-sarif@v1
        evidence:
          tool: "Trivy Vulnerability Scanner"
        with:
          rule_level:
            - critical
```
The policy named pipeline-scanners is applied, which requires that images admitted from the my_company Dockerhub repository undergo vulnerability scanning using Trivy. The check-vulnerabilities rule is defined within this policy, configured to check for any critical vulnerabilities in the image. If critical vulnerabilities are detected, the policy will trigger a violation, indicating a failure.

For CI integrations see [CI integration](https://scribe-security.netlify.app/docs/integrating-scribe/ci-integrations/)


<details>
  <summary> Collecting evidence in pipeline </summary>

For all our [CI integration](https://scribe-security.netlify.app/docs/integrating-scribe/ci-integrations/), the relevant fields are automatically set by our CI integration. 

However, if you need to mock this locally, you can manually set the `RUN_ID` and `WORKFLOW` fields while collecting evidence. Once set, you can proceed to collect your scanner report and attach it as evidence in the pipeline.

```bash
# Create evidence in the pipeline
RUN_ID=44 WORKFLOW=my_workflow.yaml valint bom busybox:latest [FLAGS]

# Generate a third-party report 
trivy image --format sarif -o report.sarif busybox:latest

# Attach the third-party SARIF report as evidence in the pipeline
RUN_ID=44 WORKFLOW=my_workflow.yaml valint evidence report.sarif [FLAGS]
```
</details>


### Product
> Option only available when using `scribe` store.

The product option evaluates policies based on the product, allowing you to verify critical aspects of the product evidence associated with the image.

```yaml
select:
  gate: product_gate
  apply:
  - namespace: ""
    glob: 
    - "**"
    product-key: my-product
    filter-by:
    - product
    policy:
      name: pipeline-scanners
      rules:
      - name: check-vulnerabilities
        uses: sarif/verify-sarif@v1
        evidence:
          tool: "Trivy Vulnerability Scanner"
        with:
          rule_level:
            - critical
```
In this example, the verify-critical-vulnerabilities policy is applied to evaluate images associated with the `my-product`. 
Specifically checking for vulnerabilities using the Trivy Vulnerability Scanner. This ensures that product undergo thorough vulnerability assessment.


<details>
  <summary> Collecting evidence in product </summary>
  
To attach evidence to a product, use the product-key and product-version flags. Then, collect your scanner report and attach it as evidence in the product.

```bash
# Create evidence in the pipeline
# Create evidence in the product
valint bom busybox:latest --product-key my_product --product-version v1 [FLAGS]

# Generate a third-party report 
trivy image --format sarif -o report.sarif busybox:latest

# Attach the third-party SARIF report as evidence in the product
valint evidence report.sarif --product-key my_product --product-version v1 [FLAGS]
```
</details>

## Default Policy - Unsigned Image Warning
By default, the provider is installed with a policy to `warning` on *ANY* image that is not signed. This serves as a basic security measure to alert users about potentially risky, unsigned images.

Default policy:
```yaml
select:
  gate: default_gate
  apply:
  - namespace: "" # Any
    glob: 
    - "**"  # Any
    filter-by:
    - target
    policy:
      name: default-provider-policy
      rules:
      - name: warn_on_unsigned_image
        uses: sboms/artifact-signed@v1
        level: "warning"
        evidence:
          signed: true
```

To pass the evaluation, you can sign your images using the valint tool, like so:
```bash
valint [bom,slsa] some_image -o attest [FLAGS]
```

Additionally, you must set up the provider to include a verification scheme, either with [X509](#X509-based-signatures) or [Sigstore](#sigstore-keyless-signatures). Refer to the relevant sections for configuration details.

## Private registries
To verify images from registries that require authentication, follow these steps:
* Set the `image.imagePullSecrets` field with base64 docker config.

For example, to perform an upgrade with your local docker config:
```bash
helm upgrade charts/gatekeeper-valint \
   --namespace gatekeeper-valint \
   --reuse-values --force \
   --set image.imagePullSecrets="$(cat ~/.docker/config.json | base64 -w0)"
```

Secret createcd should follow the following pattern
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: valint-image-pull-secret
  namespace: gatekeeper-valint
data:
  .dockerconfigjson: ewoJImF1...g==
type: kubernetes.io/dockerconfigjson
```

## Private Policy Bundles
By default policeis are pulled from our default [policy bundle](https://github.com/scribe-public/sample-policies).
To use private bundles from your preferred Git platform, follow these steps:
* Set the `image.bundlePullSecrets` with read access token to bundle git repository.
* Set `valint.attest.bundle` with your required bundle details.
* Optionaly set `valint.git.branch` or `valint.git.tag` to set the bundle git refrence to pull.

For example, to perform an upgrade with your local docker config:
```bash
helm upgrade charts/gatekeeper-valint \
   --namespace gatekeeper-valint \
   --reuse-values --force \
   --set valint.attest.bundle=https://github.com/my_company/policies.git
   --set image.bundlePullSecrets="ghp_****"
```
> Secret is stored under a secret named `valint-bundle-pull-secret`.

### Signing policy result
Currently, signing policy results are only supported when using X509 keys. To set this up:

* Set the `x509.key` field to specify the policy result signer key.
  It must be under the same CA the evidence is verified in.
  
For example, to perform an upgrade with X509-based signing:
```bash
   helm upgrade gatekeeper-valint ./charts/gatekeeper-valint \
   --namespace gatekeeper-valint \
   --reuse-values --force \
   --set valint.attest.default=x509-env \
   --set valint.verify.formats=attest \
   --set x509.ca="$(cat certs/evidence.crt)"
   --set x509.key="$(cat certs/evidence.key)"
```
> Secret is stored under a secret named `valint-x509-secret`.

> Please replace the keys and certificates generated by our `scripts/generate-tls-cert.sh` for evidence signing and verfication with your organization's trusted CA.

## Uploading signed evidence
Using valint `-o attest` flag you can upload signed evidence on the image.
```bash
valint [bom, slsa] my_image -o attest [--oci OR --scribe.enable]
```

## Alterative Evidence Stores - OCI based Store
Valint supports both storage and verification flows for `attestations` and `statement` objects using an OCI registry as an evidence store. <br />
Using OCI registry as an evidence store allows you to upload and verify evidence across your supply chain in a seamless manner.

Related configmap flags:
>* `config.attest.cocosign.storer.OCI.enable` - Enable OCI store.
>* `config.attest.cocosign.storer.OCI.repo` - Evidence store location.

### Before you begin
- Write access to upload evidence using the `valint` tool.
- Read access to download evidence for the provider.
- Evidence can be stored in any accessible OCI registry.

1. Edit the `charts/gatekeeper-valint/values.yaml` file, enable OCI client and enable a OCI repo.
   For example, 
   ```yaml
   attest:
    cocosign:
      storer:
        OCI:
          enable: true
          repo: <optional oci-repo>
   ```

   > [oci-repo] is the URL of the OCI repository where all evidence will be uploaded.
      - Example: If your oci repo is `somewhere/evidence_store` create a evidence for `example/my_image:latest`, the evidence will be stored as under `somewhere/evidence_store/image/SHA-256-DIGEST.sig`

   > Empty `oci-repo` will Attach the evidence to the same repo as the uploaded image.
    - Example: If you create a evidence for `example/my_image:latest`, the evidence will be stored as `example/my_image:SHA-256-DIGEST.sig` (oci-repo).

<!-- 2. If [oci-repo] is a private registry, attach permissions to the admission with the following steps:
    1. Create a secret:
    ```bash
    kubectl create secret docker-registry [secret-name] --docker-server=[registry_url] --docker-username=[username] --docker-password=[access_token] -n gatekeeper-valint
    ``` -->